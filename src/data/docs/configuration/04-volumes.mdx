---
title: 'Volume Configuration'
slug: 'volumes'
category: configuration

---

import Code from '@/components/code.astro'

Haloy supports both Docker named volumes and filesystem bind mounts for persistent data storage.

## Named Volumes (Recommended)

Named volumes are managed by Docker and work consistently across environments:

<Code code={`name: "my-app"
volumes:
  - "app-data:/app/data"
  - "app-logs:/var/log/app"
  - "postgres-data:/var/lib/postgresql/data"`} lang="yaml" />

### Benefits
- Managed by Docker
- Portable across environments
- Better performance on some systems
- Automatic cleanup with `docker volume prune`

## Filesystem Bind Mounts

Mount directories from the host filesystem into containers:

<Code code={`name: "my-app"
volumes:
  - "/var/app/data:/app/data"
  - "/home/user/logs:/app/logs:ro"
  - "/etc/ssl/certs:/app/certs:ro"`} lang="yaml" />

### Mount Options

Add options after the second colon:

- `ro` - Read-only mount
- `rw` - Read-write mount (default)
- `z` - SELinux label (shared content)
- `Z` - SELinux label (private content)

## Volume Format

<Code code={`# Named volume
volume-name:/container/path

# Bind mount (requires absolute path)
/absolute/host/path:/container/path[:options]`} lang="yaml" />

## Important Restrictions

### Absolute Paths Required

Filesystem bind mounts must use absolute paths starting with `/`:

**Valid:**
<Code code={`volumes:
  - "/var/log/myapp:/app/logs"
  - "/etc/ssl/private:/app/ssl:ro"`} lang="yaml" />

**Invalid (will be rejected):**
<Code code={`volumes:
  - "./data:/app/data"        # Relative path
  - "../config:/app/config"   # Relative path`} lang="yaml" />

### Why No Relative Paths?

Since `haloyd` runs inside a Docker container, relative paths would be resolved relative to the daemon container's filesystem, not your local machine. This causes:
- Unexpected directory creation inside the daemon container
- Data appearing lost or inaccessible
- Inconsistent behavior across deployments

Using absolute paths or named volumes ensures predictable, consistent behavior.

## Real-World Examples

### Web Application with Database

<Code code={`name: "my-web-app"
volumes:
  # Application uploads
  - "app-uploads:/app/public/uploads"
  # Application logs
  - "/var/log/my-web-app:/app/logs"
  # SSL certificates (read-only)
  - "/etc/ssl/certs:/app/ssl:ro"`} lang="yaml" />

### Database Container

<Code code={`name: "postgres-db"
volumes:
  # Database data (persisted across container restarts)
  - "postgres-data:/var/lib/postgresql/data"
  # Database backups
  - "/backup/postgres:/backup"
  # Custom configuration (read-only)
  - "/etc/postgresql/postgresql.conf:/etc/postgresql/postgresql.conf:ro"`} lang="yaml" />

### Multi-Container Application

<Code code={`name: "shared-storage-app"
volumes:
  # Shared volume between multiple containers
  - "shared-data:/data"
  # Container-specific logs
  - "app-logs:/var/log/app"
  # Host-mounted configuration
  - "/etc/myapp/config.yaml:/app/config.yaml:ro"`} lang="yaml" />

## Volume Management

### Listing Volumes

<Code code={`docker volume ls`} lang="bash" />

### Inspecting a Volume

<Code code={`docker volume inspect app-data`} lang="bash" />

### Removing Unused Volumes

<Code code={`docker volume prune`} lang="bash" />

### Backing Up Named Volumes

<Code code={`# Create a temporary container to backup the volume
docker run --rm -v app-data:/data -v $(pwd):/backup ubuntu tar czf /backup/app-data-backup.tar.gz /data`} lang="bash" />

### Restoring Named Volumes

<Code code={`# Create a temporary container to restore the volume
docker run --rm -v app-data:/data -v $(pwd):/backup ubuntu tar xzf /backup/app-data-backup.tar.gz -C /`} lang="bash" />

## Multi-Target Volumes

Override volumes for different deployment targets:

<Code code={`name: "my-app"
# Base volumes
volumes:
  - "app-data:/app/data"

targets:
  production:
    volumes:
      - "prod-app-data:/app/data"
      - "/var/log/prod-app:/app/logs"

  staging:
    volumes:
      - "staging-app-data:/app/data"
      - "/var/log/staging-app:/app/logs"`} lang="yaml" />

## Best Practices

1. **Use named volumes for data persistence**: More portable and easier to manage
2. **Use bind mounts for configuration**: When you need to edit files on the host
3. **Always use absolute paths for bind mounts**: Prevents unexpected behavior
4. **Mount sensitive files as read-only**: Add `:ro` to prevent accidental modification
5. **Regular backups**: Especially for named volumes containing critical data
6. **Document volume requirements**: Keep a list of required volumes in your README

## Troubleshooting

### Permission Issues

If you encounter permission errors:

<Code code={`# Check volume ownership
docker run --rm -v app-data:/data ubuntu ls -la /data

# Fix ownership (if needed)
docker run --rm -v app-data:/data ubuntu chown -R 1000:1000 /data`} lang="bash" />

### Volume Not Found

If a named volume doesn't exist, Docker creates it automatically. For bind mounts, ensure the host directory exists:

<Code code={`# Create directory before deploying
sudo mkdir -p /var/log/my-app
sudo chown $(whoami):$(whoami) /var/log/my-app`} lang="bash" />

## Next Steps

- [Configure Environment Variables](/docs/environment-variables)
- [Set up Secret Providers](/docs/secret-providers)
- [Learn about Image Configuration](/docs/image-configuration)
